<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>23. Arc routing &#8212; OptimizationModels 1.02 April 4, 2024 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=712fa57f" />
    <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=edc3226b" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css?v=8bd57eb4" />
    <script src="_static/documentation_options.js?v=d77a62b4"></script>
    <script src="_static/doctools.js?v=fd6eb6e6"></script>
    <script src="_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script>window.MathJax = "{'tex': { 'macros': {RR: '{\\bf R}', R: '{\\mathbb{R}}', bold: ['{\\bf #1}', 1] }, 'environments': {braced: ['\\left\\{', '\\right\\}'] }, 'inlineMath': [['$', '$'], ['\\(', '\\)']] } }"</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="24. Quadratic Optimization Models" href="Quadratic.html" />
    <link rel="prev" title="21. Sequencing problems: the Traveling Salesperson Problem" href="TravelingSalesPerson.html" />
<link rel="stylesheet" type="text/css" 
     href="_static/custom.css" /> 


  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="TravelingSalesPerson.html" title="Previous document"><span class="section-number">21. </span>Sequencing problems: the Traveling Salesperson Problem</a>
        </li>
        <li>
          <a href="Quadratic.html" title="Next document"><span class="section-number">24. </span>Quadratic Optimization Models</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <p class="hidden"><span class="math notranslate nohighlight">\(\newcommand{\R}{{\mathbb{R}}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\Z}{{\mathbb{Z}}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\N}{{\mathbb{N}}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\var}[1]{{\color{red}{\mathbf{#1}}}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\param}[1]{{\color{blue}{#1}}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\mathsc}[1]{{\normalfont\textsc{#1}}}\)</span>
<span class="math notranslate nohighlight">\(\def\sc#1{\dosc#1\csod}\)</span>
<span class="math notranslate nohighlight">\(\def\dosc#1#2\csod{{\rm{#1{\rm\small #2}}}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\set}[1]{{\sc#1}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\mathvar}[1]{\var{#1}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\mathpar}[1]{\param{#1}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\half}{{\small{\frac{1}{2}}}}\)</span></p>
<section id="arc-routing">
<h1><span class="section-number">23. </span>Arc routing<a class="headerlink" href="#arc-routing" title="Link to this heading">¶</a></h1>
<p>By <em>Arc routing</em>  we mean the problem of finding, in a graph, a tour
which, if possible, touches every <em>arc</em> of the graph once. This is
possible if and only if the graph is Eulerian (in fact, this is the
definition of an Eulerian graph). If an Eulerian tour exists, for a
graph whose arcs are either all directed or all undirected, then
finding one of these tours is quite simple, and can be done
efficiently through polynomial time algorithms. More challenging is
the situation in which such a tour does not exist and, in order to
cover every arc at least once, it is necessary to go through some arc
in the graph more than once. If traversing an arc has a cost, the
problem arises of finding the least cost arcs whose addition to the
tour makes it possible to obtain an Eulerian tour.  In other words, we
wish to find a  tour in a graph so that every arc is covered <em>at
least</em> once. Among all tours, we would like to find a minimum cost
one.</p>
<p>This model finds many applications in real life. As an example, snow
removal might be formulated this way. In fact it is necessary to
require that a specialized vehicle goes through all the street of a
road network in order to remove snow. However, sometimes, it might be
necessary that the vehicle flows through a street where snow had been
already removed in order to reach another part of the network. The
cost of these non productive arc traversals should be minimized.</p>
<p>In cases like this one, sometimes we may assume that the network is
undirected, as emergency vehicles or snow cleaning vehicles might be allowed to travel
disregarding one way streets.</p>
<p>A similar case happens in gas meter reading or in post delivery,
when on every street
there are several devices to check, or letters and parcels to be
delivered.
In this case the cost of each
street is associated to its length, and, while traversing an arc for
reading is necessary (and can be associated a null cost), passing
through an arc just to go somewhere else is a waste to be minimized.
In this situation, if the person who does this operation is traveling,
say, on foot, then we can consider the network to be undirected, as
paths can proceed without considering one way indications. It is
however required that, as in the case of snow removal, a single passage
through an arc, in either direction, is sufficient to serve all the
requests of that road. If, on the contrary, the technician need to
serve all operations on one side of the street and only in a different
passage will serve the opposite side, than we will need to consider
the network as fully oriented, with each arc split into two directed
arcs with opposite directions.</p>
<p>There might exist situations in which some arc is directed while
some others are not. In this situation the complexity of the problem
significantly increases, as it also happens in other apparently
similar cases like those in which only a subset of the arcs need
be covered. Both variants, even in the basic case in
which a tour passing exactly once through each required arc exists,
are characterized by high complexity and to date no polynomial time
algorithm is known to exactly solve them.</p>
<p>Arc routing problems  are well studied in the scientific
literature, both from the theoretical as well as from the
computational and applied point of view. An early introduction to this
topic can be found in <span id="id1">[<a class="reference internal" href="Bibliography.html#id15" title="Jack Edmonds. The Chinese postman problem. Operations Research, 13, Suppl. 1:B73-B77, 1963.">Edmonds, 1963</a>]</span>, where the problem is named
<span class="target" id="index-0"></span>Chinese postman problem - it seems that the name derives from
one side from the natural application to post delivery and, from the
other side, from the fact that the problem was apparently first
studied and analyzed by a Chinese scientist.</p>
<p>A possibility to solve some instances of this problem might be that of
reducing it to a TSP one: in the case of post delivery, assigning a
node to the extremes of each arc and an arc between
any pair of  nodes whose cost corresponds to a shortest path between
he nodes, the problem becomes equivalent to an optimal
sequencing one.</p>
<p>However, in the completely directed as well as in the completely
undirected cases, the Chinese postman problem can be efficiently
solved through the exploitation of some fundamental properties of
Eulerian graphs, which we recall here without proof - we refer the
interested reader to the many good introductory books on graph theory
like, e.g., <span id="id2">[<a class="reference internal" href="Bibliography.html#id35" title="Béla Bollobás. Modern graph theory. Volume 194 of Graduate Texts in Mathematics. Springer-Verlag, 1998.">Bollobás, 1998</a>]</span>.</p>
<p>A fundamental property, connected to the early studies of Leonard
Euler, is that a connected undirected graph has an Eulerian path if
and only if every node has even degree, which means that in every node
an even number of arcs are incident.</p>
<p>A similar fundamental property holds for directed <em>strongly connected</em> graphs:
an Eulerian path exists if and only if the <em>out-degree</em> of every arc is
equal to the <em>in-degree</em>. The <span class="target" id="index-1"></span>out-degree of a node is the number of arcs
out from the node, and similarly for the <span class="target" id="index-2"></span>in-degree. And we
also recall that a graph is <span class="target" id="index-3"></span>strongly connected if and only if
a directed path exists between any pair of nodes.</p>
<p>Differently from what we did in all this volume, we do not give here a
formulation of the problem, but only a formulation of the sub-problem
consisting in identifying the minimum cost arcs to be traversed more
than once in order to obtain an Eulerian graph. We just show here the
directed case, as it immediately translates to an easy linear
optimization problem.</p>
<p>Let us denote by <span class="math notranslate nohighlight">\(\mathpar{\Gamma}^+_i\)</span> and
<span class="math notranslate nohighlight">\(\mathpar{\Gamma}^-_i\)</span> the out- and in-degree of a node
<span class="math notranslate nohighlight">\(i\)</span>. If the graph is not already Eulerian, there exist nodes for
which these two quantities differ. Let <span class="math notranslate nohighlight">\(\set{S}\)</span> be the set of
nodes for which <span class="math notranslate nohighlight">\(\mathpar{\Gamma}^+_i - \mathpar{\Gamma}^-_i &lt;0\)</span>
and with <span class="math notranslate nohighlight">\(\set{T}\)</span> the set of nodes for which
<span class="math notranslate nohighlight">\(\mathpar{\Gamma}^+_i - \mathpar{\Gamma}^-_i &gt;0\)</span>. The problem
now becomes that of finding a set of arcs to add to the graph, at
minimum cost, in order to balance the in and out degrees.  Assume we
would like to decrease the  imbalanced node <span class="math notranslate nohighlight">\(i \in \set{S}\)</span> with node
<span class="math notranslate nohighlight">\(j \in \set{T}\)</span>. We might do so by adding a directed path
between the two nodes: in fact, adding one such path will increase by
one the outdegree of the starting node, increase by one the in-degree
of the ending node, while keeping the balance of all intermediate
nodes. Of course, among many possible paths, it is convenient
to choose a least cost one.</p>
<p>So let us pre-process the graph by computing, for every pair
<span class="math notranslate nohighlight">\((i,j): i \in S, j \in T\)</span>, the least cost path, whose cost we denote
by <span class="math notranslate nohighlight">\(\mathpar{C}_{ij}\)</span>. Then a minimum  cost arc augmentation of the
graph  can be obtained solving the linear programming model</p>
<div class="math notranslate nohighlight">
\begin{align*}
\min \sum_{(i,j) \in \set{S} \times \set{T}} \mathpar{C}_{ij} \var{x}_{ij}
\\
\sum_{j \in \set{T}} \var{x}_{ij} &amp; = \mathpar{\Gamma}^+_i -
\mathpar{\Gamma}^-_i &amp; \forall\,i &amp; \in \set{S}\\
\sum_{i \in \set{S}} \var{x}_{ij} &amp; = \mathpar{\Gamma}^-_i -
\mathpar{\Gamma}^+_i &amp; \forall\,j &amp; \in \set{T} \\
\var{x}_{ij} &amp; \geq 0 &amp; \forall\, i, j &amp; \in \set{S} \times \set{T}
\end{align*}</div><p>It is worth noticing that this is a very easy network flow problem,
belonging to the special class of problems analyzed in the section
devoted to
“<a class="reference internal" href="Transportation.html#the-transportation-model"><span class="std std-ref">The transportation model</span></a>”. As such it can be very efficiently
solved and the optimal solution enjoys the integrality property.</p>
<p>As an example consider the following network:</p>
<blockquote>
<div><div class="figure" style="text-align: center"><p><img  src="_images/tikz-51892fcafe0e217abb256aa6b74e28c2ed0ec8a9.png" alt="Figure made with TikZ" /></p>
</div></div></blockquote>
<p>It can be immediately seen that some nodes are not balanced. In particular:</p>
<div class="math notranslate nohighlight">
\begin{align*}
\begin{array}{|c|c|}\hline
i &amp; \mathpar{\Gamma}^+_i -
\mathpar{\Gamma}^-_i \\ \hline
A &amp; \phantom{-}1 \\
C &amp; -2 \\
D &amp; \phantom{-}1 \\
E &amp; \phantom{-}1 \\
H &amp; -1 \\ \hline
\end{array}
\end{align*}</div><p>This means that <span class="math notranslate nohighlight">\(A\)</span> has one more exiting arc then entering
ones, while <span class="math notranslate nohighlight">\(C\)</span> has 2 less.
The shortest paths from nodes with negative to positive imbalance are:</p>
<div class="math notranslate nohighlight">
\begin{align*}
\begin{array}{cccc}\hline
i &amp; j &amp;  \textrm{path} &amp; \textrm{cost}\\ \hline
C &amp; A &amp; CFEDA &amp; 32 \\
C &amp; D &amp; CFED &amp; 26 \\
C &amp; E &amp; CFE &amp; 19 \\
H &amp; A &amp; HFEDA &amp; 29 \\
H &amp; D &amp; HFED &amp; 23 \\
H &amp; E &amp; HFE &amp; 16
\end{array}
\end{align*}</div><p>and by running a specialized transportation model</p>
<div class="literal-block-wrapper docutils container" id="id3">
<div class="code-block-caption"><span class="caption-text">arcrouting.mod</span><a class="headerlink" href="#id3" title="Link to this code">¶</a></div>
<div class="highlight-ampl notranslate"><div class="highlight"><pre><span></span><span class="kd">set</span><span class="w"> </span><span class="nv">ORIGINS</span><span class="p">;</span>
<span class="kd">set</span><span class="w"> </span><span class="nv">DESTINATIONS</span><span class="p">;</span>

<span class="kd">set</span><span class="w"> </span><span class="nv">ARCS</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span>ORIGINS<span class="w"> </span><span class="kr">cross</span><span class="w"> </span>DESTINATIONS<span class="p">;</span>

<span class="kd">param</span><span class="w"> </span><span class="nv">Cost</span><span class="w"> </span><span class="p">{</span>ARCS<span class="p">};</span>
<span class="kd">param</span><span class="w"> </span><span class="nv">Balance</span><span class="p">{</span>ORIGINS<span class="w"> </span><span class="kr">union</span><span class="w"> </span>DESTINATIONS<span class="p">};</span>

<span class="kd">var</span><span class="w"> </span><span class="nv">Transp</span><span class="p">{</span>ARCS<span class="p">}</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="kd">minimize</span><span class="w"> </span><span class="nv">minCost</span><span class="p">:</span>
<span class="w">	</span><span class="kr">sum</span><span class="p">{(</span>i<span class="p">,</span>j<span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span>ARCS<span class="p">}</span><span class="w"> </span>Cost<span class="p">[</span>i<span class="p">,</span>j<span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span>Transp<span class="p">[</span>i<span class="p">,</span>j<span class="p">];</span><span class="w">  </span>

<span class="kd">s.t.</span><span class="w"> </span><span class="nv">Out</span><span class="p">{</span>i<span class="w"> </span><span class="kr">in</span><span class="w"> </span>ORIGINS<span class="p">}:</span>
<span class="w">	</span><span class="kr">sum</span><span class="p">{</span>j<span class="w"> </span><span class="kr">in</span><span class="w"> </span>DESTINATIONS<span class="p">:</span><span class="w"> </span><span class="p">(</span>i<span class="p">,</span>j<span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span>ARCS<span class="p">}</span><span class="w"> </span>Transp<span class="p">[</span>i<span class="p">,</span>j<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span>Balance<span class="p">[</span>i<span class="p">];</span>

<span class="kd">s.t.</span><span class="w"> </span><span class="nv">In</span><span class="p">{</span>j<span class="w"> </span><span class="kr">in</span><span class="w"> </span>DESTINATIONS<span class="p">}:</span>
<span class="w">	</span><span class="kr">sum</span><span class="p">{</span>i<span class="w"> </span><span class="kr">in</span><span class="w"> </span>ORIGINS<span class="p">:</span><span class="w"> </span><span class="p">(</span>i<span class="p">,</span>j<span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span>ARCS<span class="p">}</span><span class="w"> </span>Transp<span class="p">[</span>i<span class="p">,</span>j<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span>Balance<span class="p">[</span>j<span class="p">];</span>
</pre></div>
</div>
</div>
<p>on data</p>
<div class="literal-block-wrapper docutils container" id="id4">
<div class="code-block-caption"><span class="caption-text">arcrouting.dat</span><a class="headerlink" href="#id4" title="Link to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span> <span class="n">ORIGINS</span> <span class="o">:=</span> <span class="n">C</span> <span class="n">H</span> <span class="p">;</span>
<span class="nb">set</span> <span class="n">DESTINATIONS</span> <span class="o">:=</span> <span class="n">A</span> <span class="n">D</span> <span class="n">E</span><span class="p">;</span>
<span class="n">param</span> <span class="n">Cost</span><span class="o">:=</span>
   <span class="n">C</span>  <span class="n">A</span> <span class="mi">32</span>
   <span class="n">C</span>  <span class="n">D</span> <span class="mi">26</span>
   <span class="n">C</span>  <span class="n">E</span> <span class="mi">19</span>
   <span class="n">H</span>  <span class="n">A</span> <span class="mi">29</span>
   <span class="n">H</span>  <span class="n">D</span> <span class="mi">23</span>
   <span class="n">H</span>  <span class="n">E</span> <span class="mi">16</span>
<span class="p">;</span>

<span class="n">param</span> <span class="n">Balance</span><span class="o">:=</span>
<span class="n">A</span> <span class="mi">1</span>
<span class="n">C</span> <span class="o">-</span><span class="mi">2</span>
<span class="n">D</span> <span class="mi">1</span>
<span class="n">E</span> <span class="mi">1</span>
<span class="n">H</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">;</span>
</pre></div>
</div>
</div>
<p>the optimal solution turns out to be to add paths <span class="math notranslate nohighlight">\(CA,CD,HE\)</span>
with total cost 74. This means that several arcs have to be added in
order to obtain an Eulerian graph:</p>
<blockquote>
<div><div class="figure" style="text-align: center"><p><img  src="_images/tikz-3b9d3e5892c91ec5ecea691a215af8ad6ef8a1cb.png" alt="Figure made with TikZ" /></p>
</div></div></blockquote>
<p>Now the augmented graph is perfectly balanced and, according to the
theory, an Eulerian path exists. How to find such a path is beyond the
scope of this volume which, we recall, is devoted to modeling more
than to algorithms. However one of the procedure is rather simple: it
suffices first to decompose the graph into directed cycles. This can be
done, e.g., starting from any node and following an outbound arc which
had not been previously chosen
until the starting node is repeated. Once a cycle is detected it is temporarily
canceled from the graph and the procedure repeats. After this step,
starting from one of the cycles, as soon as a node in common with
another cycle is found, the path follows a diversion covering such a
tour and, iteratively, this is done until all tours are merged into a
single one. In the example we might split the graph into cycles in
many possible ways, one of which is:</p>
<blockquote>
<div><div class="figure" style="text-align: center"><p><img  src="_images/tikz-ed59d1e9b6fe7df3f42abd1216243977091f2e5d.png" alt="Figure made with TikZ" /></p>
</div><p>After this split of the graph it is relatively straightforward to
derive precise directions to cover all arcs. As an example, we might
follow the blue path from A to F, then cover the two cycles in orange
and in red starting from F, followed by the green path again
from F. After, the path might return to the original blue one up to
D, divert to the cyan path DACFD and finally return to A.</p>
<p>This procedure can be easily implemented and allows to solve even
large scale arc routing problems on directed graphs in a very
efficient way. A similar procedure exists for undirected graphs. On
the opposite, there are many arc routing problems which belong to the
class of NP-hard problems for which no polynomial time method is
known. Among these, two of the best known and most widely studied are
routing problems on mixed graphs (where both directed arcs and
undirected edges are to be covered) and arc routing problems in which
only a subset of arcs need to be covered, while others are just meant
to allow transportation but are not required to be traversed.</p>
<p>Linear optimization formulations of these problems are available, but
we think they are beyond the scope and level of this volume.</p>
</div></blockquote>
<p><a class="reference external" href="https://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="CreativeCommonsLicence" src="_images/Cc-by-nc-nd_icon.svg.png" /></a></p>
<p>© Fabio Schoen 2024</p>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="TravelingSalesPerson.html" title="Previous document"><span class="section-number">21. </span>Sequencing problems: the Traveling Salesperson Problem</a>
        </li>
        <li>
          <a href="Quadratic.html" title="Next document"><span class="section-number">24. </span>Quadratic Optimization Models</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="contents.html">
              <img class="logo" src="_static/OM.jpg" alt="Logo of OptimizationModels"/>
            </a></p>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="contents.html">Document start page</a><ul>
      <li>Previous: <a href="TravelingSalesPerson.html" title="previous chapter"><span class="section-number">21. </span>Sequencing problems: the Traveling Salesperson Problem</a></li>
      <li>Next: <a href="Quadratic.html" title="next chapter"><span class="section-number">24. </span>Quadratic Optimization Models</a></li>
  </ul></li>
</ul>
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;Fabio Schoen,  v 1.02 / April 4th, 2024, Creative Commons Cc-by-nc-nd.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 9.0.4</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/Arcrouting.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>